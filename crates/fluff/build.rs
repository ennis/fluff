use shader_bridge::{compile_and_embed_shaders, rustfmt_file, translate_slang_shared_decls};
use std::env;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};

/// Path to the shader directory.
const SHADERS_DIR: &str = "slang/";
/// Shader containing declarations shared between host & shader code.
const SLANG_SHARED: &str = "slang/shared.slang";

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let shader_bindings = out_dir.join("bindings.rs");

    {
        let mut output = File::create(&shader_bindings).unwrap();
        writeln!(
            &mut output,
            "/* This file is generated by build.rs. Do not edit this file. */"
        )
        .unwrap();

        // Translate `slang/shared.slang`
        let slang_shared = Path::new(SLANG_SHARED);
        // FIXME: this works, more or less, but the RustRover doesn't update its browsing info
        //        when a shader is changed (need to clear the caches). This results in an extremely
        //        poor developer experience. There wasn't a problem when we did the opposite
        //        (generating shader code from rust structs).
        translate_slang_shared_decls(slang_shared, &mut output);

        // Compile and embed shaders
        let shaders_dir = Path::new(SHADERS_DIR);
        compile_and_embed_shaders(shaders_dir, &[], &out_dir, &mut output);
    }

    rustfmt_file(&shader_bindings);
}
