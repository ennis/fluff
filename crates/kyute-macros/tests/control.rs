use std::cell::Cell;
use std::rc::Rc;
use paste::paste;
use kyute::{text, Component, ComponentHolder};
use kyute::handler::Handler;
use kyute::layout::Axis;
use kyute::widgets::button::button;
use kyute::widgets::frame::{Frame, FrameLayout, FrameStyle};
use kyute::widgets::text::Text;
use kyute::widgets::text_edit::TextEdit;
use kyute_dsl::Control;
use kyute_macros::control;


control! {
    pub control Spinner;

    /// Test property.
    // (PAIN) this generates a lot of stuff implicitly: a private field, a public method, and a
    // setter method. It's not easily discoverable by the user on the rust side, but maybe that's a necessary tradeoff.
    pub property value: i32;

    /// Emitted when the value is changed by the user.
    event changed_by_user();

    Frame {
        TextEdit[text_edit] {
            text: {
                // (PAIN) where is `self.value()` defined? It's not obvious that it's a method of the
                // `Spinner` struct that was automatically generated.
                self.value().to_string()
                // ALT: this is not verbatim rust code, as `value` is not in scope here. This is parsed manually,
                // the `value` resolves to a property in this component, and the expression is then
                // translated to `self.value().to_string()`.
                value.to_string()
                // (ISSUE) how to resolve this? is `text` a field access or a property binding?
                // We can resolve `text_edit`, but we know nothing of its properties.
                // Also, you won't find a field named `text` in the `TextEdit` struct, because
                // it's a property implemented as a getter/setter pair.
                text_edit.text.to_string()
            };
            text_changed_by_user() => {
                // (PAIN) where is the definition of `self.set_value()`? Same as above, there's an
                // issue with public items being implicitly generated by the macro.
                self.set_value(parse_value(text_edit.text()));
                // (PAIN) where is `emit_changed_by_user()` defined? Same as above. You won't find
                // it by searching for the identifier.
                self.emit_changed_by_user();
            };
        }

        Button[inc] {
            label: "+ Increment";
            clicked() => {
                value += 1;
                changed_by_user();
            };
        }

        Button[dec] {
            label: "- Decrement";
            clicked() => {
                value -= 1;
                changed_by_user();
            };
        }
    }
}

// It's possible to implement methods outside the control! macro. However they won't be able to
// access named elements.
impl Spinner {
    fn parse_value(&self, value: &str) -> i32 {
        self.text_edit.text.parse().unwrap_or(0)
    }
}

// INSIGHT: this approach really wants its own concepts of properties and events. These do not
// map smoothly to rust code.
// Q: Do we want a smooth interop with rust code, or do we want our own language with all bells and whistles, and minimal boilerplate?

// Consider hot-reloading?
// Properties and events would not be hot-reloadable because they are generated at compile time.
// However, the tree structure and property bindings may still be hot-reloadable.
//
// Proposal: bindings and event handlers translate to a dynamic IR, names are resolved at run-time.
// On the rust side, mark properties and functions as visible to the IR.

#[test]
fn test_control_decl() {}